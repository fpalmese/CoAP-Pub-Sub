broker starts a coap server with a root resource (/ps)
broker simply calls the "listen" from CoAP class of coapthon server
coapthon server listen:
	create a transaction with the request through the messagelayer's method receive_request
	if request is NOT duplicated call the method of coapthon server receive_request
coapthon server receive_request:
	call the receive_request from the blocklayer (take the reception block-wise)
	call the receive_request from the observelayer (if observe = 0 add the subscription, if observe = 1 remove it) DOES IT WORK?
	call the receive_request from the requestlayer (take request and execute the correct method). Create the response.
		case GET: call the get_resource in the resourcelayer (if not found return "NOT_FOUND", if unsubscribe just send "unsubscribed)
		case PUT: 
		case POST:
		case DELETE:
	







MODIFIED THINGS FOR TESTING:
	COAP PUB-SUB
		the qos=1 PSClient contains a callback to retrieve the response without blocking the client
		the callback in the runningthread is called with an external thread
		the runningthread if you use a PUT place the request payload in the response(to display in the files for testing)
	COAP:
		The qos=1 publish contains a callback
		The send_request if on PUT uses a pubcallback to send a message and retrieve the response without waiting(qos=1)
	MQTT-SN:
		every request (connect,register,publish) is now placed in a while to resend until the ACK is received
		this way the client can receive a PUBACK when qos=1 is used (before, it never looked for the puback)
		modified connect keepalive-> now it works
		added qos =2 waiting for pubrec, sending pubrel and receiving pubcomp





NOTE: 
	1)copper doesn't send a "observe = 1" to remove the subscription when it receives a update from an old subscription it just sends to the server a RST with that token
	2)il client coapthon non interrompe il thread di observe dopo l'unsubscribe



INSTALL personal lib with "pip install -e path" or "python3 -m pip install -e path"

DIFFERENZE TEORICHE MQTT-SN E COAP:
	OK) CoAP usa DISCOVERY per i topic, mqtt no
	OK) MQTT-SN deve mantenere una connessione-> da questo derivano connect, ping, will, disconnect
	OK) MQTT-SN usa topic-id: da questo deriva la register
	OK) MQTT-SN puo usare delle wildcard per registrarsi a piu topic
	OK) COAP si basa su risorse che possono essere create e cancellate
	OK) MQTT puo fare subscribe a topic che non esistono visto che un topic è solo una stringa
	OK) MQTT gestisce duplicati con mid e dup, coap con solo il mid capisce
	OK) COAP associa richieste e risposte con un TOKEN
	OK) la notifica di Coap è una risposta, la notifica di mqtt è una publish
	OK)Confronto tra QoS di COAP and MQTT
	OK)in COAP il server sceglie la QoS per i subscribers, in MQTT i sub scelgono

	OK) possibilità di read per coap, non per mqtt
	OK)COAP di base usa il retain, mqtt ha la possibilità di farlo
	NO) coap di base manda risposte ad ogni richiesta essendo request-response, a meno che non sia specificato il "no-response"

	OK) coap consente il riordinamento delle notifiche di un topic tramite Observe, mqtt no (manda la publish e stop)

	confronto tra header nella teoria (tabella magari) o nella pratica boh
